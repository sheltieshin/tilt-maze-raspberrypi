<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tilt Maze â€“ Smooth Axis Lock</title>

  <style>
    body { font-family: system-ui, -apple-system, sans-serif; padding: 16px; background:#f6f7f9; }
    h2 { margin: 0 0 10px 0; }
    button { font-size: 18px; padding: 10px 16px; margin: 6px 0; width: 100%; }
    .box { margin-top: 12px; padding: 12px; background:#fff; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    .small { color:#555; font-size: 14px; }
    .win { margin-top:10px; font-size:22px; font-weight:700; color:#2e7d32; }
  </style>
</head>

<body>
  <h2>ğŸ“¦ Tilt Mazeï¼ˆå–®è»¸å„ªå…ˆï¼‹é †æ»‘ï¼‹ä¸æ•æ„Ÿï¼‰</h2>

  <button id="btnEnable">Enable Motion</button>
  <button id="btnPause">Pause Sensing</button>
  <button id="btnNeutral">Set Neutralï¼ˆç¾åœ¨å§¿å‹¢ = å¹³ï¼‰</button>
  <button id="btnCenter">Center Platform</button>

  <div class="box">
    <div>betaï¼ˆå‰å¾Œï¼‰: <span id="beta">0</span></div>
    <div>gammaï¼ˆå·¦å³ï¼‰: <span id="gamma">0</span></div>
    <div>è¼¸å‡º X / Y: <span id="xy">0 , 0</span></div>
    <div class="small">Status: <span id="status">idle</span></div>
    <div class="win" id="win"></div>
  </div>

<script>
/* ===============================
   æ§åˆ¶åƒæ•¸ï¼ˆä½ è¦çš„ï¼šæ›´ç©©ã€æ›´ä¸æ•æ„Ÿï¼‰
   =============================== */

// å‚³é€é »ç‡ï¼ˆmsï¼‰â€” æ…¢ä¸€é»æ›´ç©©
const SEND_INTERVAL = 180;

// å°è§’åº¦ä¸å‹•ï¼ˆä½ è¦ã€Œè§’åº¦å¤ å¤§æ‰å‹•ã€ï¼‰
const DEADZONE = 0.26;

// æœ€å¤§æœ‰æ•ˆè§’åº¦ï¼ˆè¶Šå°è¶Šæ•æ„Ÿï¼›æˆ‘å€‘å·²ç”¨ deadzone+gain æ§åˆ¶ï¼‰
const MAX_DEG = 18;

// å¹³æ»‘ï¼ˆè¶Šå°è¶Šé †ã€è¶Šæ…¢ï¼‰
const EMA_ALPHA = 0.08;

// é‡åŒ–éšæ¢¯ï¼ˆè¶Šå°è¶Šç´°ã€æŠ–æ›´å°‘ï¼‰
const STEP = 0.12;

// è®ŠåŒ–å¤ªå°ä¸é€ï¼ˆæŠ‘åˆ¶æŠ–ï¼‰
const SEND_EPS = 0.06;

// å¢ç›Šï¼šè®“ Y æ¯” X å¤§
const TILT_GAIN_X = 0.30;   // X å°ä¸€é»ï¼ˆæ€•çƒé£›ï¼‰
const TILT_GAIN_Y = 0.70;   // Y å¤§ä¸€é»ï¼ˆä½ è¦çš„ï¼‰

// æœ€å¤§è¼¸å‡ºé™åˆ¶ï¼ˆå®‰å…¨å¸¶ï¼‰
const MAX_OUT_X = 0.30;
const MAX_OUT_Y = 0.65;

const X_GAIN_POS = 1.2;   // å‰å‚¾æ”¾å¤§
const X_GAIN_NEG = 0.6;   // å¾Œå‚¾ç¸®å°ï¼ˆä¿å‘½ï¼‰

/* ===============================
   æ–¹å‘åè½‰ï¼ˆå¦‚æ–¹å‘ä¸å°æ”¹æˆ 1ï¼‰
   =============================== */
const INVERT_X = 1;
const INVERT_Y = 1;

/* ===============================
   å–®è»¸å„ªå…ˆï¼ˆé¿å…å‰å¾Œæ™‚ X äº‚å‹•ï¼‰
   =============================== */
let axisLock = null;        // 'x' / 'y' / 'none'
let lockUntil = 0;
const LOCK_MS = 300;        // é–ä¹…ä¸€é»ï¼Œä¸æœƒè·³ä¾†è·³å»
const DOMINANCE = 1.35;     // ä¸»è¦è»¸è¦å¤§æ–¼æ¬¡è¦è»¸çš„å€ç‡
const ACTIVATE = 0.18;      // â­ ä¸»è¦è»¸è‡³å°‘è¦åˆ°é€™å€‹å¼·åº¦æ‰æœƒå‹•

/* ===============================
   ç‹€æ…‹
   =============================== */
let enabled = false;
let sensing = true;
let lastSend = 0;

// EMA ç‹€æ…‹
let emaX = 0;
let emaY = 0;

// ä¸Šæ¬¡é€å‡ºçš„å€¼
let lastOutX = 0;
let lastOutY = 0;

// ä¸­ç«‹æ ¡æº–å€¼
let neutralBeta = 0;
let neutralGamma = 0;
let neutralSet = false;

// yaw è£œå„Ÿï¼ˆé¿å…ä½ è½‰æ‰‹æ©Ÿæ–¹å‘æ™‚è»¸äº‚æ‰ï¼‰
let neutralAlpha = 0;
let lastAlpha = 0;

/* ===============================
   DOM
   =============================== */
const betaEl = document.getElementById('beta');
const gammaEl = document.getElementById('gamma');
const xyEl = document.getElementById('xy');
const statusEl = document.getElementById('status');
const winEl = document.getElementById('win');
const btnPause = document.getElementById('btnPause');

/* ===============================
   å·¥å…·å‡½å¼
   =============================== */
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function normalize(deg) { return clamp(deg / MAX_DEG, -1, 1); }
function deadzone(v, dz) { return Math.abs(v) < dz ? 0 : v; }
function quantize(v, step) { return Math.round(v / step) * step; }

/* ===============================
   API
   =============================== */
async function sendXY(x, y) {
  try {
    const res = await fetch('/api/tilt', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ x, y })
    });
    const data = await res.json();
    statusEl.textContent = `X_PWM=${data.x_pwm} Y_PWM=${data.y_pwm}` + (sensing ? '' : ' (paused)');
    if (data.won) winEl.textContent = "ğŸ‰ WIN!";
  } catch {
    statusEl.textContent = 'send error';
  }
}

/* ===============================
   Buttons
   =============================== */
document.getElementById('btnEnable').onclick = async () => {
  winEl.textContent = "";
  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
    const perm = await DeviceMotionEvent.requestPermission();
    enabled = (perm === 'granted');
  } else {
    enabled = true;
  }
  statusEl.textContent = enabled ? 'motion enabled' : 'motion denied';
};

btnPause.onclick = async () => {
  sensing = !sensing;
  btnPause.textContent = sensing ? 'Pause Sensing' : 'Resume Sensing';
  statusEl.textContent = sensing ? 'sensing resumed' : 'sensing paused';

  // æš«åœæ™‚é€ 0,0 å›ä¸­ç«‹
  if (!sensing) {
    axisLock = null;
    lockUntil = 0;
    lastOutX = 0;
    lastOutY = 0;
    await sendXY(0, 0);
  }
};

document.getElementById('btnNeutral').onclick = () => {
  neutralSet = true;
  neutralAlpha = lastAlpha;     // è¨˜ yaw
  statusEl.textContent = 'neutral set âœ”';
};

document.getElementById('btnCenter').onclick = async () => {
  winEl.textContent = "";
  await fetch('/api/center', { method: 'POST' });
};

/* ===============================
   Device Orientation
   =============================== */
window.addEventListener('deviceorientation', (e) => {
  if (!enabled) return;

  const beta = e.beta || 0;    // å‰å¾Œ
  const gamma = e.gamma || 0;  // å·¦å³
  const alpha = e.alpha || 0;  // yaw

  lastAlpha = alpha;

  betaEl.textContent = beta.toFixed(1);
  gammaEl.textContent = gamma.toFixed(1);

  // å°šæœªæ ¡æº–ä¸­ç«‹å‰ï¼Œä¸é€æ§åˆ¶
  if (!neutralSet) {
    neutralBeta = beta;
    neutralGamma = gamma;
    neutralAlpha = alpha;
    xyEl.textContent = "0 , 0ï¼ˆè«‹å…ˆ Set Neutralï¼‰";
    return;
  }

  // æš«åœæ™‚ï¼šå®Œå…¨ä¸é€æ§åˆ¶
  if (!sensing) {
    xyEl.textContent = "paused";
    return;
  }

  // ç›¸å°å‚¾æ–œ
  const relBeta = beta - neutralBeta;
  const relGamma = gamma - neutralGamma;

  // yaw è£œå„Ÿï¼šè½‰æ‰‹æ©Ÿæ–¹å‘ä¹Ÿç¶­æŒç›´è¦º
  const yaw = (alpha - neutralAlpha) * Math.PI / 180.0;
  const xRight = relGamma * Math.cos(yaw) - relBeta * Math.sin(yaw);
  const yForward = relGamma * Math.sin(yaw) + relBeta * Math.cos(yaw);

  // normalize
  let x = normalize(xRight);
  let y = normalize(yForward);

  // é™ä½æ•æ„Ÿï¼ˆå¢ç›Šï¼‰
  x *= TILT_GAIN_X;
  y *= TILT_GAIN_Y;

  // deadzoneï¼šå°è§’åº¦ä¸å‹•
  x = deadzone(x, DEADZONE);
  y = deadzone(y, DEADZONE);

  // EMA å¹³æ»‘
  emaX = EMA_ALPHA * x + (1 - EMA_ALPHA) * emaX;
  emaY = EMA_ALPHA * y + (1 - EMA_ALPHA) * emaY;

  // é‡åŒ–
  let outX = quantize(emaX, STEP);
  let outY = quantize(emaY, STEP);

  // æ–¹å‘åè½‰
  outX *= INVERT_X;
  
  // â­ X è»¸å‰å¾Œä¸å°ç¨±å¢ç›Šï¼ˆé—œéµï¼‰
 if (outX > 0) {
   outX = outX * X_GAIN_POS;  // å‰å‚¾
 } else if (outX < 0) {
   outX = outX * X_GAIN_NEG;  // å¾Œå‚¾
 }

  outY *= INVERT_Y;

  // æœ€å¤§è¼¸å‡ºé™åˆ¶ï¼ˆå®‰å…¨å¸¶ï¼Œé¿å…çƒé£›ï¼‰
  outX = clamp(outX, -MAX_OUT_X, MAX_OUT_X);
  outY = clamp(outY, -MAX_OUT_Y, MAX_OUT_Y);

  // âœ… å–®è»¸å„ªå…ˆï¼ˆé¿å…å‰å¾Œæ™‚ X äº‚å‹•ï¼‰
  const ax = Math.abs(outX);
  const ay = Math.abs(outY);
  const t = Date.now();

  if (t > lockUntil) {
    if (ax >= ACTIVATE && ax > ay * DOMINANCE) {
      axisLock = 'x';
      lockUntil = t + LOCK_MS;
    } else if (ay >= ACTIVATE && ay > ax * DOMINANCE) {
      axisLock = 'y';
      lockUntil = t + LOCK_MS;
    } else {
      axisLock = 'none'; // ä¸å¤ æ˜é¡¯ â†’ ç›´æ¥ä¸å‹•ï¼ˆæœ€ç©©ï¼‰
      lockUntil = t + 80;
    }
  }

  if (axisLock === 'x') outY = 0;
  else if (axisLock === 'y') outX = 0;
  else { outX = 0; outY = 0; }

  xyEl.textContent = `${outX.toFixed(2)} , ${outY.toFixed(2)} (${axisLock})`;

  // è®ŠåŒ–å¤ªå°ä¸é€ï¼ˆæŠ‘åˆ¶æŠ–ï¼‰
  const dx = Math.abs(outX - lastOutX);
  const dy = Math.abs(outY - lastOutY);
  if (dx < SEND_EPS && dy < SEND_EPS) return;

  // å€¼æ²’è®Šå°±ä¸é€
  if (outX === lastOutX && outY === lastOutY) return;

  const now = Date.now();
  if (now - lastSend > SEND_INTERVAL) {
    lastSend = now;
    lastOutX = outX;
    lastOutY = outY;
    sendXY(outX, outY);
  }
}, true);
</script>

</body>
</html>

